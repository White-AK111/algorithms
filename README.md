# algorithms
Solving algorithmic problems on Go.
---------------------------------------------------------

***pkg - stones***

### A. Камни и украшения [тестовая задача]

Ограничение времени | 1 секунда
---|---
Ограничение памяти | 64Mb
Ввод | стандартный ввод или input.txt
Вывод | стандартный вывод или output.txt

Даны две строки строчных латинских символов: строка J и строка S. Символы, входящие в строку J, — «драгоценности», входящие в строку S — «камни». Нужно определить, какое количество символов из S одновременно являются «драгоценностями». Проще говоря, нужно проверить, какое количество символов из S входит в J.
Это разминочная задача, к которой мы размещаем готовые решения. Она очень простая и нужна для того, чтобы вы могли познакомиться с нашей автоматической системой проверки решений. Ввод и вывод осуществляется через файлы, либо через стандартные потоки ввода-вывода, как вам удобнее.

Формат ввода
На двух первых строках входного файла содержатся две строки строчных латинских символов: строка J и строка S. Длина каждой не превосходит 100 символов.
Формат вывода
Выходной файл должен содержать единственное число — количество камней, являющихся драгоценностями.

Пример
Ввод | Вывод
---|---
ab | 4
aabbccd | 

---------------------------------------------------------
***pkg - units***

### B. Последовательно идущие единицы

Ограничение времени | 1 секунда
---|---
Ограничение памяти | 64Mb
Ввод | стандартный ввод или input.txt
Вывод | стандартный вывод или output.txt

Требуется найти в бинарном векторе самую длинную последовательность единиц и вывести её длину.

Желательно получить решение, работающее за линейное время и при этом проходящее по входному массиву только один раз.

Формат ввода
Первая строка входного файла содержит одно число n, n ≤ 10000. Каждая из следующих n строк содержит ровно одно число — очередной элемент массива.

Формат вывода
Выходной файл должен содержать единственное число — длину самой длинной последовательности единиц во входном массиве.

Пример
Ввод | Вывод
---|---
5 | 3
1 | 
1 | 
1 | 
0 | 
1 | 
0 | 
1 | 
1 | 

---------------------------------------------------------
***pkg - duplicates***

### C. Удаление дубликатов
Язык | Ограничение времени | Ограничение памяти | Ввод | Вывод
---|---|---|---|---
Все языки | 1 секунда | 10Mb | стандартный ввод или input.txt | стандартный вывод или output.txt
Node.js 14.15.5 | 1 секунда | 20Mb | |  
Oracle Java 7 | 1 секунда | 20Mb | | 
Kotlin 1.4.30 (JRE 11) | 1 секунда | 20Mb | | 
Oracle Java 8 | 1 секунда | 20Mb | | 
Kotlin 1.1.50 (JRE 1.8.0) | 1 секунда | 20Mb | | 
Kotlin 1.3.50 (JRE 1.8.0) | 1 секунда | 20Mb | | 
Node JS 8.16 | 1 секунда | 20Mb | | 

Дан упорядоченный по неубыванию массив целых 32-разрядных чисел. Требуется удалить из него все повторения.

Желательно получить решение, которое не считывает входной файл целиком в память, т.е., использует лишь константный объем памяти в процессе работы.

Формат ввода
Первая строка входного файла содержит единственное число n, n ≤ 1000000.

На следующих n строк расположены числа — элементы массива, по одному на строку. Числа отсортированы по неубыванию.

Формат вывода
Выходной файл должен содержать следующие в порядке возрастания уникальные элементы входного массива.

Пример 1
Ввод | Вывод
---|---
5 | 2
2 | 4
4 | 8
8 | 
8 | 
8 | 

Пример 2
Ввод | Вывод
---|---
5 | 2
2 | 8
2 | 
2 | 
8 | 
8 | 

---------------------------------------------------------
***pkg - brackets***

### D. Генерация скобочных последовательностей

Ограничение времени | 1 секунда
---|---
Ограничение памяти | 20Mb
Ввод | стандартный ввод или input.txt
Вывод | стандартный вывод или output.txt

Дано целое число n. Требуется вывести все правильные скобочные последовательности длины 2 ⋅ n, упорядоченные лексикографически (см. https://ru.wikipedia.org/wiki/Лексикографический_порядок).

В задаче используются только круглые скобки.

Желательно получить решение, которое работает за время, пропорциональное общему количеству правильных скобочных последовательностей в ответе, и при этом использует объём памяти, пропорциональный n.

Формат ввода
Единственная строка входного файла содержит целое число n, 0 ≤ n ≤ 11

Формат вывода
Выходной файл содержит сгенерированные правильные скобочные последовательности, упорядоченные лексикографически.

Пример 1
Ввод | Вывод
---|---
2 | (())
. | ()()

Пример 2
Ввод | Вывод
---|---
3 | ((()))
. | (()())
. | (())()
. | ()(())
. | ()()()

---------------------------------------------------------
***pkg - anagrams***

### E. Анаграммы

Ограничение времени | 1 секунда
---|---
Ограничение памяти | 20Mb
Ввод	| стандартный ввод или input.txt
Вывод	| стандартный вывод или output.txt

Даны две строки, состоящие из строчных латинских букв. Требуется определить, являются ли эти строки анаграммами, т. е. отличаются ли они только порядком следования символов.

Формат ввода
Входной файл содержит две строки строчных латинских символов, каждая не длиннее 100 000 символов. Строки разделяются символом перевода строки.

Формат вывода
Выходной файл должен содержать единицу, если строки являются анаграммами, и ноль в противном случае.

Пример 1
Ввод	| Вывод
---|---
qiu | 1
iuq | 

Пример 2
Ввод	| Вывод
---|---
zprl | 0
zprc | 

---------------------------------------------------------
***pkg - credit. Падает на 13-м тесте, скорее всего при чтении входных данных***

### B. Технический долг

Ограничение времени	| 2 секунды
---|---
Ограничение памяти | 256Mb
Ввод | стандартный ввод или input.txt
Вывод	| стандартный вывод или output.txt

Реализация большого проекта — очень сложная задача, и при разработке программист Алексей руководствуется следующим принципом: сначала написать работающий прототип, а потом улучшать код. Чтобы не забыть, что именно отложено на потом, на каждый такой долг Алексей заводит на себя задачу в специальной системе Yagile.
Система устроена следующим образом: для каждой задачи задается дедлайн — день 
ti. Если задача не решена до этого момента времени, то в задачу приходит робот и пишет комментарий о том, что задачу надобно закрыть. Если через X дней задача не решена, то робот приходит снова. Так продолжается до тех пор, пока задача не будет решена.
Алексей каждый день заходит в Yagile и видит сообщения от робота. Если Алексей не хочет приступать к решению накопленных задач, то он прочитывает все сообщения с помощью одной кнопки и занимается другими делами. Однако Алексей понимает, что так долго делать нельзя, поэтому он разрешает себе нажимать на эту кнопку ровно 
K−1 раз, а на K-й раз садится и решает все задачи разом (даже те, у которых не настал дедлайн).
Определите день, когда Алексей закроет все задачи.

Формат ввода
Первая строка содержит три целых числа 
N (1≤N≤10 в степени 5) — количество накопленных задач, 
X (1≤X≤10 в степени 9) — количество дней, через которое приходит робот и число 
K из условия (1≤K≤10 в степени 9).
Вторая строка содержит 
N целых чисел t1, t2, …, tN (1≤ti≤10 в степени 9) — дедлайны соответствующих задач.

Формат вывода
Выведите одно число — день, когда Алексей закроет все задачи.

Пример 1
Ввод | Вывод
---|---
6 5 10 | 10
1 2 3 4 5 6 | 

Пример 2
Ввод | Вывод
---|---
5 7 12 | 27
5 22 17 13 8 | 

Примечания
Во втором примере Алексей завёл 5 задач, и каждые 7 дней, начиная с дня дедлайна, робот оставляет комментарий. Например, в первой задаче робот будет оставлять комментарии в дни 5, 12, 19, 26, 33, и т. д. Если рассмотреть все комментарии робота по задачам Алексея, то они будут написаны в следующие дни: 5, 8, 12, 13, 15, 17, 19, 20, 22 (во 2-й и 5-й задачах одновременно), 24, 26, 27, 29, 
…
 На 12-й по счёту день Алексей закроет все задачи, чему соответствует день 27.
